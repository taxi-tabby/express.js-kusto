const fs = require('fs');
const path = require('path');

function buildRoutes() {
    console.log(`🔨 Scanning routes for webpack build...`);
    
    try {
        console.log(`✅ Routes will be bundled into the virtual file system using routes-map.ts`);
        console.log(`📁 Source: src/app/routes/`);
        console.log(`📁 Target: Generated in src/core/lib/routes-map.ts`);
        console.log(`📄 Routes will be dynamically imported at runtime`);
          // 소스 라우트 파일 목록 표시
        const sourcePath = 'src/app/routes';
        if (fs.existsSync(sourcePath)) {
            console.log(`📊 Source route files:`);
            listFiles(sourcePath, '  ');            const routeCount = countRouteFiles(sourcePath);
            console.log(`📊 Total route files: ${routeCount.routes}, middleware files: ${routeCount.middlewares}`);
            console.log(`✅ Route preparation completed. Files will be bundled into the virtual file system.`);
            console.log(`ℹ️ Route map will be generated by the generate-routes-map script.`);
        } else {
            console.warn(`⚠️ Source routes directory not found: ${sourcePath}`);
            console.error(`❌ Cannot proceed with build. Please create the routes directory at: ${sourcePath}`);
            process.exit(1);
        }
        
    } catch (error) {
        console.error(`❌ Route build preparation failed:`, error.message);
        process.exit(1);
    }
}

function listFiles(dir, prefix = '') {
    if (!fs.existsSync(dir)) return;
    
    const items = fs.readdirSync(dir);
    for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
            console.log(`${prefix}📁 ${item}/`);
            listFiles(fullPath, prefix + '  ');
        } else {
            const ext = path.extname(item);
            const icon = ext === '.js' ? '📄' : ext === '.ts' ? '📝' : '📄';
            console.log(`${prefix}${icon} ${item} (${formatBytes(stat.size)})`);
        }
    }
}

function countRouteFiles(dir) {
    let routes = 0;
    let middlewares = 0;
    
    function traverse(currentDir) {
        if (!fs.existsSync(currentDir)) return;
        
        const items = fs.readdirSync(currentDir);
        for (const item of items) {
            const fullPath = path.join(currentDir, item);
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory()) {
                traverse(fullPath);
            } else if (item.endsWith('.ts') || item.endsWith('.js')) {
                if (item === 'route.ts' || item === 'route.js') routes++;
                if (item === 'middleware.ts' || item === 'middleware.js') middlewares++;
            }
        }
    }
    
    traverse(dir);
    return { routes, middlewares };
}

function formatBytes(bytes) {
    if (bytes < 1024) return `${bytes}B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
}

// 실행
buildRoutes();
